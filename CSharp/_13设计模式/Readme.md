# ﻿一、编程思想

### 编程思想四个模块内容：

1. 面向对象

2. 设计原则

3. 设计模式

4. 基于面向对象、设计原则、设计模式的设计类的应用

#### 编程思想的特点：

可落地、可外显。

1. 可落地：可以应用在代码中，可以应用在程序的设计中。

2. 可外显：可直观的从代码中看出来。

#### 使用编程思想的目的：

能够使我们的代码，去承载项目中很复杂的业务逻辑，并且使代码看起来非常的简洁易懂，易于扩展。

1. 承载：

- 代码只有在使用了编程思想才能够具备承载很复杂的业务逻辑。

- 高纬度思考可将淘宝先分两个模块：商家卖货、买家买货
- 但当开发产品时要一直深挖，如：
  “商家卖货”中拆成：订单系统、物流系统、文件系统
  “买家买货”中拆成：直播系统、红包雨系统、秒杀系统

2. 复杂的业务逻辑：

- 业务逻辑的定义：用户实现或者完成一个功能的最简单或者最小的闭环。

- 哪些元素凑到一起称之为是业务逻辑呢？
  - 流程环节:
  - 人机交互

  - 数据交互

- 举一个“订单系统”的业务逻辑进行分析：

  - 流程环节：用户先浏览商品的详情页---点击加入购物车---点击购买---商家端判断货够不够---判断是否给用户优惠---判断是否给用户优惠券---最后完成提交订单
  - 人机交互：用户和产品之间的交互。产品经理来设计，开发人也必须具备设计人机交互的能力。比如：界面要做成什么样子才能让用户在第一时间看到我想展示给用户的内容。
  - 数据交互：比如展示给用户的订单详情页、商品详情页、库存....
  - 将“订单系统”继续进行拆分：
    - （用户选好商品之后）生成订单---支付订单---商家发货---确认收货---订单完成
    - “生成订单”继续拆分：用户下单、商品信息、优惠信息、会员权益、库存减少、运费计算
    - “支付订单”继续拆分：用户信息、支付信息
    - “商家发货”继续拆分：商家发货、仓库调拨、订单分拣、商品包装、订单出库、快递配送
    - “确认收货”继续拆分：物流追踪、用户签收
    - “交易完成”继续拆分：用户评价、订单售后
      将“生成订单”继续进行拆分
      用户下单、商品信息、优惠信息、会员权益、库存减少、运费计算
      程序员继续以图形化的形式对“生成订单”进行“流程环节、人机交互、数据交互”的开发
      首先考虑流程环节，才能去考虑后续的人机交互和数据交互。
      流程环节要以图形化的样子表示出来，画出业务流程图。
      流程图中有相关的数据交互设计。
      人机交互需要产品经理做原型图，程序员进行实现。

3. 易于扩展：

   由于产品经理不停的进行需求变化，比如：
   对产品添加新的功能：这种情况下编程思想要求我们只添加新代码，不修改源代码。
   对产品原功能进行业务修改：这种情况下编程思想要求我们在修改原功能的基础上，不影响其他功能的执行。
   满足上边两个条件说明代码是易于扩展的。
   
   悟、打磨、加深理解、内化

# 二、编程思想的核心——高内聚、低耦合

### 1、高内聚（可靠性、可读性）

设计思想的核心：高内聚、低耦合。位于金字塔最底部（非常重要）。

编程思想之间的关系：按照金字塔原理自下而上为：“高内聚，低耦合→设计原则（7个）→设计模式→面向对象”

高内聚：模块内部元素具有相同特点的相似程度。

高内聚提供了更好的程序可靠性、可读性。
模块的组成
接口：模块的输入和输出。（如方法的参数和返回值）
功能：模块实现了什么功能。
逻辑：模块的内部如何实现要求的功能，以及在实现功能的过程中所需要的数据。
状态：模块调用与被调用的关系。
当一段代码既有输入和输出，又实现了一段功能，并且有实现功能所需的业务逻辑和所需的数据，最后还和其他代码之间有调用和被调用的关系，那么就称之为一个模块。
小到一个方法、一个接口、一个类，大到一个业务、一个功能、一个系统，都是模块。
高内聚的“新闻管理”类和“用户管理”类的例子
内部元素：
“新闻管理”类：方法“新闻查看、新闻更新、新闻删除”，仅关于新闻的
“用户管理”类：方法“设置用户名、设置密码、用户注册、用户删除”，仅关于用户的
低内聚的例子
“新闻管理”类的方法中出现了和用户相关的方法，如：“新闻查看、新闻更新、新闻删除、用户删除”
低内聚会给我们带来什么问题？
当程序需要对用户的“用户删除”进行修改时，就需要去“新闻管理”类进行修改，而如果某个程序集引用了新闻管理集，就需要对这个程序集进行重新生成并发版（此操作无价值）。

### 2、低耦合（可扩展性、复用性）

低耦合：指的是模块之间的依赖程度。

低耦合提供了更好的程序可扩展性和可复用性。
低耦合是使得不同模块之间的联系程度降到最低。
低耦合的例子
主板和显卡的使用互不影响
“电源插座”提供接口给“手机、电视、烧水壶”，他们之间的使用互不影响。
数据层和UI界面如果直接相连代表高耦合，但数据DAO(数据访问对象)和Form窗体的交互通过中间层Controllor控制器进行交互就代表着低耦合，其中解耦就是解了数据层和窗体的耦，此时不管是对数据或者是对窗体进行修改，对彼此都互不影响，因为中间是通过控制器进行关联着的。

# **三、设计原则**

### 单一职责原则（Single Responsibility Principle）

**单一职责：有且只有一个原因引起类变更。**

**也就是说，当一个类，只干了一件事，就是符合单一职责原则。**

1. 比如：当一个类只有在添加的时候才会触动类的改变，符合单一职责原则。
2. 或者：当一个类中只有一个方法会存在修改的情况从而触动类的改变，且不再在类中新增方法时，也符合单一职责原则。

反之，当一个类做了很多件事，也就有很多种可能性会引起类的变更，这个时候类就变得非常脆弱、不稳定。

1. 比如TelPhone类干了四件事，也就是有四种可能性来修改类的代码。
2. 此外还有添加“开机、关机”的新的方法事也需要修改类的代码。

**综上，类的变化有两种：**

1. 内部的变化：如果TelPhone内部的方法中任意一个发生了变化，都会需要修改TelPhone，也就是有四种可能性来修改类的代码，该类不符合单一职责。
2. 外部的变化：如果TelPhone要添加新的方法“开机、关机”，也需要修改TelPhone，添加新方法这种情况是合理的。但是之后类中已存在的方法需要再次进行修改时就产生了多个可能性，该类也不符合单一职责了。



如果将方法的实现写到类里边，那么无论无何都会有多种可能性去修改这个类，则该类不具备单一职责。

**所以功能的实现不能写到定义为单一职责的类里边。如何做呢？**

1. 将每一个方法单独的写成一个类，在类里边只写一个方法，最终在TelPhone中进行简单的调用。
2. 将每一个方法提炼出一个接口，抽象成一种能力，然后分别写子类去继承，再实现接口，最终在TelPhone中进行简单的调用。（这里将TelPhone类定义为单一职责类）
3. 未来可能会有很多类要继承这个接口，所以在TelPhone类中调用的时候要调用的是接口的对象。
4. 引起TelPhone类变化的原因，只有在给这个类添加新功能的时候。而如果修改这个类中的方法的实现时，并不是在TelPhone类中做改变，而是在实现这些功能的子类中进行修改。

**单一职责原则的好处：**

1. 提高了代码的可读性，提高系统的可维护性。
2. 降低类的复杂性，一个模块只负责一个职责，提高系统的可扩展性和可维护性。
3. 降低变更引起的风险。变更是必然的，但如果单一职责做的好，在出现修改一个功能的时候可以显著降低对另一个功能的影响。

### 开放封闭原则（Open Closed Principle）（7大原则中最重要的）

**开放封闭原则的重要性：**“开放封闭原则”是面向对象中7大原则的核心，是最重要的。

**开放封闭原则提出了对程序设计的两个要求**（这两个要求是保证我们的程序符合高内聚-低耦合的一个标准）：

1. 对功能扩展开放
2. 如果需求变化，需要新增功能时，通过代码无法添加功能的话，此时不符合。
3. 当遇到修改时，代码封闭
4. 当需求改变时，需要修改很多代码，此时不允许。

**使用开放封闭原则的目的：**当需求改变时，可以做到在不改变软件实体源代码（类、接口、方法等）的前提下，通过扩展功能，使代码满足新的需求。

**如何做到使代码尽可能的符合开放封闭原则？**

1. 写代码时尽量是面向抽象编程，或者说是面向接口编程。使用抽象，来封装容易变化的地方。

**当写程序时，需要考虑：**

1. 在这段程序中，会出现多少个对象？言外之意有多少个对象就要创建多少个类。
2. 每个对象的属性和行为。

**对象分析：**

1. 用户（属性：记录不同类型的用户，如存钱的、取钱的、转账的...）
2. 银行柜员（方法：帮助用户处理不同的需求）
3. 银行业务系统（方法：处理存钱、取钱、转账等需求的操作系统）

### 设计原则总结
- 设计原则是**「高内聚、低耦合」**的具体落地。
- **单一职责原则**要求在软件系统开发、设计中，一个类只负责一个功能领域的相关职责。
- **开放封闭原则**要求一个软件应该对扩展开放，对修改封闭，即在不修改源代码的情况下，完成系统功能的扩展。
- **里式替换原则**决定了子类可以赋值给父类。
- **依赖倒置原则**要求抽象不应该依赖于细节，细节应该依赖于抽象。要面向接口编程，不要面向实现编程。
- **迪米特原则**要求一个对象尽可能少的与其他对象发生相互作用。
- **接囗隔离原则**要求客户端不应该依赖那些他不需要的接口，即将一些大的接口细化成一些小的接囗供客户端使用。
- **合成复用原则**要求我们尽量使用对象的组合，而非继承来达到复用的目标。